PF Library
Copyright (c) Oleg Volchkov
http://oleg.volchkov.net
---------------------------

Рефлексия
=========
  Методы начинаются с двух знаков подчеркивания.

  Используется в pfWebRequest (метод __add вызывается из pfModule)
  для обхода конфликта имен.
  
  @__asString[aOptions]
    Формирует строковое представление объекта класса (сериализация)
    Проверка на сериализуемость объекта: ^if($object.__asString is junction)

  @__fromString[aString]
    Метод, который позволяет создать объект класса из строки (десериализация)
    При динамическом вызове должен заполнять текущий экземпляр данными.
    При статическом вызове должен возвращть объект текущего класса с данными.
    Проверка на десериализуемость объекта: ^if($object.__fromString is junction)
  

Контроллеры
===========

 = pfModule:
    Класс позволяет вызывать методы класса (модуля), а также методы "вложенных" модулей, используя uri-подобные строки.

    В любой модуль может быть вложено произвольное количество других модулей. Глубина иерархии модулей не ограничена.
    Добавление вложенного модуля:
    @assignModule[aName;aOptions]
    ## Добавляет вложенный модуль aName
    ## aOptions.class - имя класса
    ## aOptions.file - файл с текстом класса
    ## aOptions.source - строка с текстом класса (если определена, то плюем на file)
    ## aOptions.compile(0) - откомпилировать модуль сразу 
    ## aOptions.args - опции, которые будут переданы конструктору.
    ## aOptions.faсtory - метод, который будет вызван для создания модуля
    ##                    Если определен, то при компиляции модуля вызывается код, 
    ##                    который задан в этой переменной. Предполагается, что в качестве 
    ##                    кода выступает метод, который возвращает экземпляр.
    ##                    Если определена $aOptions.args, то эта переменная будет
    ##                    передана методу в качестве единственного параметра.
    ##                    Пример:
    ##                     ^addModule[test;$.factory[$moduleFactory] $.args[test]]
    ##                      
    ##                     @moduleFactory[aArgs]
    ##                       $result[^pfModule::create[$aArgs]]
    
    Вложенные модули поддерживают процедуру "ленивой загрузки", т.е. компиляция текста модуля и создание объекта происходит только при попытке выхова модуля при маршрутизации или при вызове свойства modName.
    
    Запуск маршрутизации осуществляется через метод
    @dispatch[aAction;aRequest]
    ## aAction    Действие, которое необходимо выполнить
    ## aRequest   Параметры экшна
   
    
 == Базовая схема маршрутизации
    Обработчиками экшнов являются методы модулей, имена которых формируются по схеме onActioName, а сами методы принимают один еинственный параметр в который передается объект (по-умолчанию хеш), который содержит параметры экшна. Экшны регистронезависимы, т.е. some/action и SoMe/AcTIon приведут к вызову одного и того же обработчика. 
    
    Метод dispatch пытается отыскать для экшна "/some/action/name.ext" (концевые слэши удаляются перед обработкой и не влияют на результат) в текущем модуле метод-обработчик по следующим правилам (правила выполняются последовательно, после первого совпадения обработка прекращается):                                      
    - Если у нас имеется вложенный модуль some, то вызывается метод dispatch модуля some, которому передается часть экшна следующая за именем модуля (action/name.ext). Можно перехватить вызов метода вложенного модуля создав в основном модуле метод onSome. В этом случае методика вызов вложенного модуля определяется программистом. 
    - Если в модуле определен метод onSomeActionNameExt (экшн переводится в нижний регистр, разбивается на части по слешам и точкам, первые буквы частей преобразовываются в верхний регистр и все части объединяются в строку), то вызываем его.
    - Если в модуле определен метод onDEFAULT, то вызываем его. Этот же метод вызывается, если экшн пустой.
   
    
 == Расширенная маршрутизация
    Для обработки сложных экшнов предусмотрена гибкая схема преобразования экшнов на основе шаблонов.
   
    Программист может определить свою собственную схему маршрутизации перекрыв в модуле метод:
    @rewriteAction[aAction;aRequest]
    ## Вызывается каждый раз перед диспатчем - внутренний аналог mod_rewrite.
    ## $result.action - новый экшн.
    ## $result.args - параметры, которые надо добавить к аргументам и передать обработчику. 
    ## $result.prefix - префикс, который необходимо передать диспетчеру

    pfModule предоставляет схему преобразования урлов на основе механизма, реализованного в классе pfRouter. Добавление правил преобразования производится путем вызова метода assign объекта pfModule.router класса pfRouter.                     
    
    @assign[aPattern;aRouteTo;aOptions]
    ## Добавляет новый шаблон aPattern в список маршрутов 
    ## aRouteTo - новый маршрут (может содержать переменные)
    ## aOptions.defaults[] - хеш со значениями переменных шаблона "по-умолчанию" 
    ## aOptions.requirements[] - хеш с регулярными выражениями для проверки переменных шаблона
    ## aOptions.prefix[] - дополнительный, вычисляемый префикс для путей (может содержать переменные)
    
    Шаблон aPattern может содержать статические части, а также переменные, которые будут переданы как параметры обработчику, определяемому по пути в переменной aRouteTo. 
    
    Рассмотрим пример шаблона:
    path1/path2/:some/:where/:{arg1}-:arg2.:format/*trap
    дополнительные условия: aOptions.requirements[$.where[\d+] $.arg2[\d+]]
    
    Переменные шаблона начинаются с двоеточия. Если возникает неоднознаяная ситуация с определением имени переменной (например, в случае, когда следующий за переменной текст начинается с символа, который может бфть в переменной), то необходимо заключать имя переменной в фигурные скобки(:{name}). Переменная, начинающаяся со звездочки поглощает в себя всю оставшуюся часть пути (*name). Для более точного распознавания маршрутов рекомендуется задавать регулярные выражения для переменных через aOptions.requirements.           
    Обратите внимание, что динамическая часть шаблона (начинается с места объявления первой переменной) является необязательной. При этом можно задать хеш aOptions.defaults - переменные из него будут использоваться, если не удалось найти переменную в маршруте.
    Новый маршрут (aRouteTo) может содержать переменные, которые будут получены после применения к оригинальному маршруту или будут заданы через aOptions.defaults. Если переменную найти не получится, то будет возбуждено искючение.

    Для задания преобразования дл пустого маршрута (aPattern[]) необходимо использовать метод pfModule.router.root:
    @root[aRouteTo;aOptions]
    ## Добавляет действие для пустого роута
    ## aRouteTo - новый маршрут (может содержать переменные)
    ## aOptions.defaults[] - хеш со значениями переменных шаблона "по-умолчанию" 
    ## aOptions.prefix[] - дополнительный, вычисляемый префикс для путей (может содержать переменные)   

    Непосредственное преобразование маршрута выполняется методом pfModule.router.route:
    @route[aPath;aOptions]
    ## Выполняет поиск и преобразование пути по списку маршрутов
    ## result[$.action $.args $.prefix]    
    
    Метод пытается найти первый подходящий шаблон и выполняет преобразование маршрута или возвращает оригинальный маршрут. После первого совпадения дальнейшая обработка прерывается. Вызов этого метода производится автоматически в pfModule.rewriteAction. 
    
    
    === Пример преобразования
    
    ^router.assign[:id/:ip/*trap;ip/:ip/:trap;
      $.requirements[
        $.ip[\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}] 
        $.id[\d+]
      ] 
      $.prefix[/clients/:id]
    ]       

    ^router.route[111/192.168.0.1/some/action/path]
    result: [ 
      $.action[ip/192.168.0.1/some/action/path]
      $.args[
        $.id[111]
        $.ip[192.168.0.1]
        $.trap[/some/action/path]
      ]
      $.prefix[/clients/111]
    ]


    === Префиксы
    
    Префикс (aOptions.prefix), вычисляемый для маршрута, может быть полезен при организации иерархий модулей и использовании REST-маршрутов.
    
    TODO                                                                                                                                            
    
    
    
    -----------------
    Внутренние детали
    
    Рассматриваемый шаблон будет преобразован в следующее регулярное выражение:
    ^path1\/path2(?:\/([^\./]+)(?:/(\d+)(?:/([^\./]+)-(\d+)(?:\.([^\./]+)(?:/(.+))?)?)?)?)?$    
      
    Применение шаблона к пути path1/path2/got/123/23-45.xml/last/path/part даст следующий результат:
    $.some[got] $.where[123] $.arg1[23] $.arg2[45] $.format[xml] $.trap[last/path/part]
    -----------------     
    


 == Составление и бэкрезолв урлов  
    
    Функция полностью не реализована, но текущая схема задания маршрутов сильно упрощает ее написание.
    Скоро!            
    
    В настоящий момент в модулях можно использовать метод:
    @linkTo[aAction;aOptions;aAnchor]
    ## Формирует url для экшна
    ## $uriPrefix$aAction?aOptions.foreach[key=value][&]#aAnchor
    
    
 
 = pfSiteModule и pfSiteManager
    Класс pfSiteModule (наследник pfModule) расширяет схему маршрутизации и позволяет производить постобработку результатов работы обработчиков.
   
    Ответом модуля может быть строка или объект с обязательными полями type и body. Строка автоматически оборачивается в класс pfHTTPResponse: сама строка попадает в поле body, а тип ответа задается исходя из переменной responseType модуля.
   
    Обработчик ответа будет вызываться после диспатча по следующему алгоритму: сначала пытаемся вызвать обработчик postTYPE, а если его нет, то зовем postDEFAULT.

    #@postHTML[aResponse]
    #@postXML[aResponse]
    #@postTEXT[aResponse]
    #@postDEFAULT[aResponse]
    
    # aResponse[$.type[html|xml|file|text|...] $.body[] ...] - хэш или объект с данными ответа.
   
    Поля, которые могут быть обработаны контейнерами (pfSiteManager) и выданы браузеру:
      $.content-type[] $.charset[] $.headers[] $.status[] $.cookie[]
      Для типа "file" можно положить ответ не в поле body, а в поле download, что по результату аналогично response:body и response:download.
   
   
   
   
   
   
   
   
   
   
   
   
       